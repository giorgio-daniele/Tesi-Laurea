import pandas
import os
import numpy as np
import seaborn
import matplotlib.pyplot as plt

from lib import Experiment
from lib import process_experiments


def compute_covering_index(tokens, weights):

    max = 0
    for token, value in weights.items():
        max += value

    score = 0
    for token in tokens:
        if token in weights:
            score += weights[token]
    return (score / max) * 100


# Define your constants
DELTA = pandas.Timedelta(seconds=3)
LIMIT = pandas.Timedelta(seconds=60 * 10)

class ViewsProcessor:

    def __init__(self, frame: pandas.DataFrame, streambot_trace_file: str, platform_profile: str, delta: pandas.Timedelta, limit: int, minimum: int):
        
        # The dataframe to be processed (input)
        self.frame = frame
        
        # The path of the platform profile to be used (input)
        self.platform_profile = platform_profile

        # The Streambot trace to be used (input)
        self.streambot_trace_file = streambot_trace_file

        # Hyperparameters
        self.minimum = minimum  # The minimum probability of a token to be considered as frequent
        self.delta = delta      # The minimum time interval between two consecutive frequent tokens
        self.limit = limit      # The maximum window size

        # The windows that have been generated by the algorithm
        self.windows: list[tuple] = []
        self.labeled_windows: list[tuple] = []


    def print_output(self):

        if len(self.labeled_windows) == 0:
            return 

        for wind_time_start, wind_time_end, wind_idx_start, wind_idx_end, window, label in self.labeled_windows:
            print(f"[{wind_time_start} - {wind_time_end}] | [{wind_idx_start} - {wind_idx_end}] - {label}")
            print()
            print(window)
            print("-" * 50)


    def generate_windows(self):

        hot_tokens, all_tokens, hotspots, windows = {}, {}, [], []

        # Process the profile file
        with open(self.platform_profile, "r") as file:

            # All tokens
            all_tokens = {t: float(v) for line in file for v, t in [line.strip().split("\t")]}

            # Hot tokens (the only tokens with probability higher than minimum)
            hot_tokens = {t: float(v) for t, v in all_tokens.items() if v >= self.minimum}

        # Make each timestamp column into a pandas date-time objects
        self.frame["DT_FP"] = pandas.to_datetime(self.frame["DT_FP"])

        # Extract all instants in which a hot token has been detected (some points on x-axis)
        hotspots = sorted(self.frame.loc[self.frame["TOKEN"].isin(hot_tokens), "DT_FP"])


        # ALGORITM of expanding window

        i, horizon = 0, None

        while i < len(hotspots):

            # Generate a window centered in the current hotspot
            ts, tn, te = hotspots[i] - self.delta, hotspots[i], hotspots[i] + self.delta

            # Manage overlapping windows
            ts = max(ts, horizon) if horizon else ts

            # Get the next point
            i += 1

            while i < len(hotspots) and hotspots[i] <= te:

                te = hotspots[i] + self.delta
                i += 1

                size = te - tn
                if size > self.limit:
                    break

            # Slice the current window in the frame
            window: pandas.DataFrame = self.frame[(self.frame["DT_FP"] >= ts) & (self.frame["DT_FP"] <= te)]

            # Append the current window to the list of windows
            if len(window) > 0:
                windows.append((ts, te, window.index[0], window.index[-1], window))

            # Update the new horizon
            horizon = te

        self.windows = windows


    def label_windows_3a(self, intervals: list[tuple[int, int]]):

        visited = set()

        # Loop over all windows, selecting the timestamps of the first and last occurences,
        # alongside the indeces of such elements
        for wind_time_start, wind_time_end, wind_idx_start, wind_idx_end, window in self.windows:
            
            match = False

            # Loop over all intervals
            for int_start, int_end in intervals:

                # Check if there an intersection between the window and the current interval
                if max(wind_idx_start, int_start) <= min(wind_idx_end, int_end):

                    # Check if this interval has already been marked intersected with
                    # another window in the past
                    
                    if (int_start, int_end) in visited:
                        item = (wind_time_start, wind_time_end, wind_idx_start, wind_idx_end, window, "NEGATIVE")
                        self.labeled_windows.append(item)
                    else:
                        item = (wind_time_start, wind_time_end, wind_idx_start, wind_idx_end, window, "POSITIVE")
                        self.labeled_windows.append(item)
                        visited.add((int_start, int_end))

                    # We find an intersection
                    match = True
                    break

            if not match:
                item = (wind_time_start, wind_time_end, wind_idx_start, wind_idx_end, window, "NEGATIVE")
                self.labeled_windows.append(item)


    def label_windows_3b(self, intervals: list[tuple[int, int]]):

        # Loop over all windows, selecting the timestamps of the first and last occurences,
        # alongside the indeces of such elements
        for wind_time_start, wind_time_end, wind_idx_start, wind_idx_end, window in self.windows:
            
            match = False

            # Loop over all intervals
            for int_start, int_end in intervals:

                # Check if there an intersection between the window and the current interval
                if max(wind_idx_start, int_start) <= min(wind_idx_end, int_end):

                    item = (wind_time_start, wind_time_end, wind_idx_start, wind_idx_end, window, "POSITIVE")
                    self.labeled_windows.append(item)

                    # We find an intersection
                    match = True
                    break

            if not match:
                item = (wind_time_start, wind_time_end, wind_idx_start, wind_idx_end, window, "NEGATIVE")
                self.labeled_windows.append(item)

if __name__ == "__main__":

    desktop_profile = os.path.join(os.getcwd(), "desktop-profile.dat")
    mobile_profile  = os.path.join(os.getcwd(), "mobile-profile.dat")

    experiments: list[Experiment] = process_experiments(None, ["tg", "rai", "quattro", "cinque", "sport"])

    experiment = experiments[0]

    frame = experiment.estat_tcp_complete_frame
    streambot_trace_file = experiment.streambot_trace_file
    profile = desktop_profile
    delta = DELTA
    limit = LIMIT
    minimum = 0.86


    processor: ViewsProcessor = ViewsProcessor(frame, streambot_trace_file, profile, delta, limit, minimum)
    processor.generate_windows()

    # for ts, te, window in processor.windows:
    #     print(f"T-start = {ts} - T-end = {te} | Duration = {(te - ts).total_seconds():.2f}s")
    #     print(window)
    #     print()

    processor.generate_windows()
    intervals = [(view["first_row"], view["last_row"]) for view in experiment.views]
    processor.label_windows_3a(intervals)

    os.system("clear")

    processor.print_output()

    # # Statistics about samples
    # tpr = 0
    # fpr = 0
    # tnr = 0
    # fnr = 0

    # # Settings for the classifier
    # profile  = os.path.join(os.getcwd(), "desktop-profile.dat")
    # minimum  = 0.86
    # treshold = 50.0

    # step  = 0.5
    # min_s = 0.5
    # max_s = 1.0#60 * 5

    # compute_stats(experiments=experiments[:1], profile=profile, minimum=minimum, treshold=treshold, delta=pandas.Timedelta(seconds=15))







# def expanding_windows_generator(frame: pandas.DataFrame, profile: str, minimum: int, delta: pandas.Timedelta):

#     """
#     Generate time windows around instances of frequent server tokens.

#     This function reads a profile file to identify server tokens and 
#     their frequencies. It then generates time windows around instances 
#     where frequent tokens (above a minimum threshold) are observed in 
#     the given DataFrame.
#     """

#     hot_tokens, all_tokens, hotspots, fragments = {}, {}, [], []

#     # Process the profile file
#     with open(profile, "r") as file:

#         # All tokens
#         all_tokens = {t: float(v) for line in file for v, t in [line.strip().split("\t")]}

#         # Hot tokens (the only tokens with probability higher than minimum)
#         hot_tokens = {t: float(v) for t, v in all_tokens.items() if v >= minimum}

#     # Convert column in which is reported the timestamp of the first packet
#     # that has traversed the connection into a pandas date-time objects
#     frame["DT_FP"] = pandas.to_datetime(frame["DT_FP"])

#     # Extract all instants in which a hot token has been detected
#     hotspots = sorted(frame.loc[frame["TOKEN"].isin(hot_tokens), "DT_FP"])

#     idx, horizon = 0, None

#     # Loop over all instants
#     while idx < len(hotspots):

#         # Generate the basic window area: centered in the hotspots
#         ts, tn, te = hotspots[idx] - delta, hotspots[idx], hotspots[idx] + delta

#         # Ensure the start time of the current window does not
#         # overlap with the end of the previous window
#         ts = max(ts, horizon) if horizon else ts

#         # Extend the current window end time (te) to include subsequent
#         # instances within delta
#         while idx < len(hotspots) and hotspots[idx] <= te:

#             te = hotspots[idx] + delta
#             idx += 1

#             # Break if the window duration exceeds the specified LIMIT
#             if te - tn >= LIMIT:
#                 break

#         # Slice the current window in the frame
#         fragment = frame[(frame["DT_FP"] >= ts) & (frame["DT_FP"] <= te)]

#         # Compute the score
#         scoring = compute_covering_index(set(fragment["TOKEN"]), hot_tokens)

#         # Add this to the result
#         fragments.append((fragment, scoring))

#         # Update the new horizon
#         horizon = te

#     return fragments

# def assign_truth_3B(intervals: list[tuple[int, int]], windows: list[object]) -> list[tuple]:

#     samples = []
    
#     # Loop over all windows
#     for window, score in windows:

#         if len(window) == 0:
#             continue
        
#         # Get the start and end indices of the window
#         s, e = window.index[0], window.index[-1]
        
#         # Flag for indicating tha the window has
#         # matched an intersection
#         found_intersection = False
        
#         # Loop over all intervals
#         for ts, te in intervals:

#             # Check if there's an intersection between the window and the current interval
#             if max(s, ts) <= min(e, te):

#                 # If there's an intersection, mark as POSITIVE and break out of the interval loop
#                 samples.append((window, score, "POSITIVE"))
#                 found_intersection = True
#                 break
        
#         # If no intersection was found with any interval, mark as NEGATIVE
#         if not found_intersection:
#             samples.append((window, score, "NEGATIVE"))


#     return samples


# def assign_truth_3A(intervals: list[tuple[int, int]], windows: list[object]) -> list[tuple]:

#     samples = []
    
#     # Set to track intervals that have been marked as POSITIVE
#     marked_intervals = set()
    
#     # Loop over all windows
#     for window, score in windows:
        
#         if len(window) == 0:
#             continue
        
#         # Get the start and end indices of the window
#         s, e = window.index[0], window.index[-1]
        
#         # Flag to track if the window has matched an intersection 
#         # with any interval
#         found_intersection = False
        
#         # Loop over all intervals
#         for ts, te in intervals:

#             # Check if there's an intersection between the window and the 
#             # current interval
#             if max(s, ts) <= min(e, te):
                
#                 # Check if this interval has already been marked as POSITIVE
#                 if (ts, te) in marked_intervals:
#                     samples.append((window, score, "NEGATIVE"))

#                 else:
#                     samples.append((window, score, "POSITIVE"))
#                     marked_intervals.add((ts, te))

#                 found_intersection = True
#                 break
        
#         # If no intersection was found with any interval, mark as NEGATIVE
#         if not found_intersection:
#             samples.append((window, score, "NEGATIVE"))
    
#     return samples

# def compute_stats(experiments, profile, minimum, treshold, delta):

#     samples = []

#     for number, experiment in enumerate(experiments):

#         # Get the frame
#         frame = experiment.tcp_flows_frame

#         # Get the intervals as streams (Ground Truth)
#         streams = experiment.verbose_streams
        
#         # Get all intervals ad segments
#         intervals = [(stream["first_row"], stream["last_row"]) for stream in streams]

#         # Generate the windows
#         windows = expanding_windows_generator(frame=frame, profile=profile, minimum=minimum, delta=delta)

#         # Generate results
#         #result = assign_truth_3A(intervals=intervals, windows=windows)
#         result = assign_truth_3B(intervals=intervals, windows=windows)

#         # Add the results
#         samples.extend(assign_truth_3A(intervals=intervals, windows=windows))

#         print(f"Intervals: {', '.join(f'({ts} - {te})' for ts, te in intervals)}")
#         print(f"Fragments: {', '.join(f'({window.index[0]} - {window.index[-1]})' for window, _ in windows)}")

#         for window, score, label in result:
#             print()
#             print("_" * 200)
#             print(f"{score} - {label}")
#             print()
#             print(window)
#             print("_" * 200)