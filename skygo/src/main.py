import pandas
import os
import numpy as np
import matplotlib.pyplot as plt

from lib import Experiment
from lib import process_experiments


def compute_covering_index(tokens: list[str], hot_tokens: dict[str, float]):

    max = 0
    for token, value in hot_tokens.items():
        max += value

    score = 0
    for token in tokens:
        if token in hot_tokens:
            score += hot_tokens[token]
    return (score / max) * 100


class Sample:

    def __init__(self, 
                 frame: pandas.DataFrame, 
                 streambot_trace_file: str, 
                    platform_profile: str, 
                    delta: pandas.Timedelta, limit: pandas.Timedelta, minimum: int, threshold: float=50.0):
        
        # The dataframe to be processed (input)
        self.frame = frame
        
        # The path of the platform profile to be used (input)
        self.platform_profile = platform_profile

        # The Streambot trace to be used (input)
        self.streambot_trace_file = streambot_trace_file

        # Hyperparameters
        self.minimum = minimum    # The minimum probability of a token to be considered as frequent
        self.delta = delta        # The minimum time interval between two consecutive frequent tokens
        self.limit = limit        # The maximum window size
        self.treshold = threshold # The score to be classified as POSITIVE

        # The windows that have been generated by the algorithm
        self.raw_windows: list[tuple] = []
        self.lab_windows: list[tuple] = []
        self.cls_windows: list[tuple] = []

        # Statistics about this experiment
        self.stats = {}

    def print_raw_windows(self):

        if len(self.raw_windows) == 0:
            print("\tNo raw windows")
            return

        for w_ts, w_te, window in self.raw_windows:

            print(f"[{w_ts} - {w_te}]")
            print()
            print(window)
            print("-" * 50)

    def print_labeled_windows(self):

        if len(self.lab_windows) == 0:
            print("No labeled windows")
            return

        for w_ts, w_te, window, label in self.lab_windows:
            print(f"[{w_ts} - {w_te}] | LAB = {label}")
            print()
            print(window)
            print("-" * 50)

    def print_classified_windows(self):

        if len(self.cls_windows) == 0:
            print("\tNo classified windows")
            return

        for w_ts, w_te, window, label, result in self.cls_windows:
            print(f"[{w_ts} - {w_te}] | LAB = {label} CLS = {result}")
            print()
            print(window)
            print("-" * 50)

    def generate_windows(self):

        all_tokens = {}
        hot_tokens = {}

        i, horizon = 0, None

        windows = []
        
        # Read from platform profile all tokens and their frequencies
        with open(self.platform_profile, "r") as file:

            for line in file:
                v, t = line.strip().split("\t")

                # Add to all tokens the current one
                all_tokens[t] = float(v)

                # Add this token to the dictionary of hot tokens
                if float(v) >= self.minimum:
                    hot_tokens[t] = float(v)

        # Convert timestamp column to pandas datetime objects
        self.frame["DT_FP"] = pandas.to_datetime(self.frame["DT_FP"])

        # Extract and sort hotspots
        hotspots = []

        for index, row in self.frame.iterrows():
            if row["TOKEN"] in hot_tokens:
                hotspots.append(row["DT_FP"])

        # Sort the resulting list
        hotspots = sorted(hotspots)

        while i < len(hotspots):
            
            # Generate a window centered on the current hotspot
            ts, tn, te = hotspots[i] - self.delta, hotspots[i], hotspots[i] + self.delta

            # Manage overlapping windows
            ts = max(ts, horizon) if horizon else ts

            # Move to the next hotspot
            i += 1

            while i < len(hotspots) and hotspots[i] <= te:
                te = hotspots[i] + self.delta
                i += 1
                if te - tn > self.limit:
                    break

            # Slice the current window and append it if non-empty
            window = self.frame[(self.frame["DT_FP"] >= ts) & (self.frame["DT_FP"] <= te)]
            
            if len(window) > 0:
                windows.append((window.index[0], window.index[-1], window))

            # Update the horizon
            horizon = te

        self.raw_windows = windows

    def label_windows_3a(self, intervals: list[tuple[int, int]]):

        visited = set()

        # Loop over all windows, selecting the timestamps of the first and last occurences,
        # alongside the indeces of such elements
        for w_ts, w_te, window in self.raw_windows:
            
            match = False

            # Loop over all intervals
            for i_ts, i_te in intervals:

                # Check if there an intersection between the window and the current interval
                if max(w_ts, i_ts) <= min(w_te, i_te):

                    # Check if this interval has already been marked intersected with
                    # another window in the past
                    
                    if (i_ts, i_te) in visited:
                        item = (w_ts, w_te, window, "NEGATIVE")
                        self.lab_windows.append(item)
                    else:
                        item = (w_ts, w_te, window, "POSITIVE")
                        self.lab_windows.append(item)
                        visited.add((i_ts, i_te))

                    # We find an intersection
                    match = True
                    break

            if not match:
                item = (w_ts, w_te, window, "NEGATIVE")
                self.lab_windows.append(item)

    def label_windows_3b(self, intervals: list[tuple[int, int]]):

        # Loop over all windows, selecting the timestamps of the first and last occurences,
        for w_ts, w_te, window in self.raw_windows:
            
            match = False

            # Loop over all intervals
            for i_ts, i_te in intervals:

                # Check if there an intersection between the window and the current interval
                if max(w_ts, i_ts) <= min(w_te, i_te):

                    item = (w_ts, w_te, window, "POSITIVE")
                    self.lab_windows.append(item)

                    # We find an intersection
                    match = True
                    break

            if not match:
                item = (w_ts, w_te, window, "NEGATIVE")
                self.lab_windows.append(item)

    def classify_windows(self, intervals):

        all_tokens = {}
        hot_tokens = {}

        # POSITIVE 
        tp = 0
        fp = 0

        # NEGATIVE
        tn = 0
        fn = 0
        
        # Read from platform profile all tokens and their frequencies
        with open(self.platform_profile, "r") as file:

            for line in file:
                v, t = line.strip().split("\t")

                # Add to all tokens the current one
                all_tokens[t] = float(v)

                # Add this token to the dictionary of hot tokens
                if float(v) >= self.minimum:
                    hot_tokens[t] = float(v)

        # Loop over all windows
        for w_ts, w_te, window, label in self.lab_windows:

            # Compute the score
            score = compute_covering_index(window["TOKEN"].tolist(), hot_tokens)
            
            if label == "POSITIVE":

                if score >= self.treshold:
                    
                    # True positive

                    item = (w_ts, w_te, window, "POSITIVE", "POSITIVE")
                    self.cls_windows.append(item)

                    # Add a new true positive
                    tp += 1
                
                if score < self.treshold:

                    # False negative

                    item = (w_ts, w_te, window, "POSITIVE", "NEGATIVE")
                    self.cls_windows.append(item)

                    # Add a new true positive
                    fn += 1

            if label == "NEGATIVE":

                if score >= self.treshold:
                    
                    # False positive

                    item = (w_ts, w_te, window, "NEGATIVE", "POSITIVE")
                    self.cls_windows.append(item)

                    # Add a new false positive
                    fp += 1
                
                if score < self.treshold:

                    # True negative

                    item = (w_ts, w_te, window, "NEGATIVE", "NEGATIVE")
                    self.cls_windows.append(item)

                    # Add a new true negative
                    tn += 1

        self.stats = {

            "fp": fp,
            "fn": fn,
            "tp": tp,
            "tn": tn,
            "win_generated": len(self.raw_windows),         # The number of windows generated (classified)
            "win_expected":  len(intervals),                # The number of windows expected
        }


def run_tests_3b(delta, test: Experiment):

    # Define a limit
    limit = pandas.Timedelta(seconds=60)

    sample = Sample(
            frame=test.estat_tcp_complete_frame, 
                streambot_trace_file=test.streambot_trace_file, 
                    platform_profile=platform_profile, delta=delta, limit=limit, minimum=0.86)

    # Generate windows (STEP 1)
    sample.generate_windows()

    # Label windows (STEP 2)
    sample.label_windows_3b([(view["first_row"], view["last_row"]) for view in test.streaming_intervals_tcp])

    # Classify windows (STEP 3)
    sample.classify_windows([(view["first_row"], view["last_row"]) for view in test.streaming_intervals_tcp])

    return sample.stats

def run_tests_3a(delta, test: Experiment):

    # Define a limit
    limit = pandas.Timedelta(seconds=60)

    sample = Sample(
            frame=test.estat_tcp_complete_frame, 
                streambot_trace_file=test.streambot_trace_file, 
                    platform_profile=platform_profile, delta=delta, limit=limit, minimum=0.86)

    # Generate windows (STEP 1)
    sample.generate_windows()

    # Label windows (STEP 2)
    sample.label_windows_3a([(view["first_row"], view["last_row"]) for view in test.streaming_intervals_tcp])

    # Classify windows (STEP 3)
    sample.classify_windows([(view["first_row"], view["last_row"]) for view in test.streaming_intervals_tcp])

    return sample.stats

if __name__ == "__main__":

    platform_profile = os.path.join(os.getcwd(), "desktop-profile.dat")

    # Process all experiments
    tests = process_experiments(None, ["tg", "rai", "quattro", "cinque", "sport"])

    print()
    print()

    y_vals = []
    x_vals = []
    p_vals = []

    # Define a delta range
    for delta in pandas.timedelta_range(start='500ms', end='60s', freq='500ms'):

        print(f"Processing with DELTA = {delta.total_seconds()} seconds")
        print("_" * 100)

        # Define statistics
        tp, tn, fp, fn = 0, 0, 0, 0

        for numb, test in enumerate(tests):
            stats = run_tests_3a(delta, test)

            # Update overall statistics for this delta
            tp += stats["tp"]
            tn += stats["tn"]
            fp += stats["fp"]
            fn += stats["fn"]

            print(f"{stats} experiment #{numb}")

        # We exit the test, so it is time to print the overall statistics
        print()
        print()
        print(f"Overall = TP: {tp}, FN: {fn}, FP: {fp}, TN: {tn}")
        print()
        print()

        # Compute True Positive Rate
        tpr = tp / (tp + fn) if tp + fn > 0 else 0

        # Compute False Positive Rate
        fpr = fp / (fp + tn) if fp + tn > 0 else 0

        x_vals.append(fpr)
        y_vals.append(tpr)
        p_vals.append(delta.total_seconds())

    # Plot the ROC curve
    plt.scatter(x=x_vals, y=y_vals, c='red', label='ROC dots')
    plt.plot([0, 1], [0, 1], color='blue', linestyle='--', label='Random Guess')
    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.xlabel("FPR (False Positive Rate)")
    plt.ylabel("TPR (True Positive Rate)")
    plt.grid(True)
    plt.legend()
    plt.show()